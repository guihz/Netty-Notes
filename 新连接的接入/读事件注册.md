### AbstractChannel#register0

- 当连接 Channel 注册到 Selector 后，具体注册可看 [register](https://github.com/martin-1992/Netty-Notes/blob/master/Netty%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/register.md)，会进行读事件的注册，调用 pipeline.fireChannelActive 方法，进行数据的读写；
- 从 tail 节点往前调用，在头节点中获取感兴趣的 IO 事件集合；
- 如果集合中不包含读事件，则将读事件注册到 selectionKey，这样就可以处理读事件。

```java
        private void register0(ChannelPromise promise) {
            try {
                if (!promise.setUncancellable() || !ensureOpen(promise)) {
                    return;
                }
                boolean firstRegistration = neverRegistered;
                //  将连接 channel 注册到 Selector 上
                doRegister();
                neverRegistered = false;
                registered = true;

                // 调用输出 handlerAdded(ChannelHandlerContext ctx)
                pipeline.invokeHandlerAddedIfNeeded();

                safeSetSuccess(promise);
                // 调用输出 channelRegistered(ChannelHandlerContext ctx)
                pipeline.fireChannelRegistered();
                // 新连接创建好，并且注册到 selector 上，则为 true
                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        beginRead();
                    }
                }
            } catch (Throwable t) {
                // Close the channel directly to avoid FD leak.
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
```

### DefaultChannelPipeline#invokeChannelActive
　　传入头节点 head，用于判断当前线程是否在 EventLoop 线程中，不是则用线程工厂 executor 创建一个线程放到任务队列中执行。

```java
    @Override
    public final ChannelPipeline fireChannelActive() {
        AbstractChannelHandlerContext.invokeChannelActive(head);
        return this;
    }
```

### AbstractChannelHandlerContext#invokeChannelActive
　　在 EventLoop 线程，调用 invokeChannelActive 方法。

```java
    static void invokeChannelActive(final AbstractChannelHandlerContext next) {
        EventExecutor executor = next.executor();
        // 当前线程为 EventLoop 线程
        if (executor.inEventLoop()) {
            next.invokeChannelActive();
        } else {
            // 不在 EventLoop 线程，则使用线程工厂 executor
            // 创建一个线程放到任务队列中执行
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    next.invokeChannelActive();
                }
            });
        }
    }

    private void invokeChannelActive() {
        if (invokeHandler()) {
            try {
                ((ChannelInboundHandler) handler()).channelActive(this);
            } catch (Throwable t) {
                notifyHandlerException(t);
            }
        } else {
            fireChannelActive();
        }
    }
```

### DefaultChannelPipeline#HeadContext
　　调用的是 pipeline 的头节点 head，即 DefaultChannelPipeline 的内置类 HeadContext 的 channelActive 方法。

```java
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        ctx.fireChannelActive();
        // 自动注册读事件，用于 Selector 轮询到读事件
        readIfIsAutoRead();
    }
```

### DefaultChannelPipeline#readIfIsAutoRead
　　默认自动读，当连接注册到 Selector 后，会向 Selector 注册读事件，自动读取数据，这里的 Channel 为服务端的 Channel。

```java
    private void readIfIsAutoRead() {
        if (channel.config().isAutoRead()) {
            channel.read();
        }
    }
    
    /**
     * AbstractChannel#read
     */
    @Override
    public Channel read() {
        pipeline.read();
        return this;
    }
```

### DefaultChannelPipeline#read
　　从 pipeline 的 tail 开始，向前传播。

```java
    @Override
    public final ChannelPipeline read() {
        // 从 pipeline 的 tail 开始，向前传播
        tail.read();
        return this;
    }
```

### AbstractChannelHandlerContext#read

- findContextOutbound，通过 while 循环找到前面的节点，不断向前传播，最后找到头节点 head；
- 当前线程为 EventLoop 线程，则调用 invokeRead 方法。

```java
    @Override
    public ChannelHandlerContext read() {
        final AbstractChannelHandlerContext next = findContextOutbound();
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeRead();
        } else {
            Tasks tasks = next.invokeTasks;
            if (tasks == null) {
                next.invokeTasks = tasks = new Tasks(next);
            }
            executor.execute(tasks.invokeReadTask);
        }

        return this;
    }
    
    private AbstractChannelHandlerContext findContextOutbound() {
        AbstractChannelHandlerContext ctx = this;
        // 通过 while 循环找到前面的节点
        do {
            ctx = ctx.prev;
        } while (!ctx.outbound);
        return ctx;
    }

    private void invokeRead() {
        if (invokeHandler()) {
            try {
                ((ChannelOutboundHandler) handler()).read(this);
            } catch (Throwable t) {
                notifyHandlerException(t);
            }
        } else {
            read();
        }
    }
```

### DefaultChannelPipeline#read
　　调用 doBeginRead 进行数据读取。

```java
    @Override
    public void read(ChannelHandlerContext ctx) {
        unsafe.beginRead();
    }
    
    /**
     * AbstractChannel#beginRead
     */
    @Override
    public final void beginRead() {
        assertEventLoop();

        if (!isActive()) {
            return;
        }
        try {
            // 核心逻辑
            doBeginRead();
        } catch (final Exception e) {
            invokeLater(new Runnable() {
                @Override
                public void run() {
                    pipeline.fireExceptionCaught(e);
                }
            });
            close(voidPromise());
        }
    }
```

### doBeginRead

- 获取感兴趣的 IO 事件集合；
- 如果集合中不包含读事件，则将读事件注册到 selectionKey，这样就可以处理读事件。

```java
    @Override
    protected void doBeginRead() throws Exception {
        // 获取 selectionKey
        final SelectionKey selectionKey = this.selectionKey;
        if (!selectionKey.isValid()) {
            return;
        }

        readPending = true;
        
        // 获取感兴趣的 IO 事件集合
        final int interestOps = selectionKey.interestOps();
        // 如果集合中不包含读事件，则将读事件注册到 selectionKey
        if ((interestOps & readInterestOp) == 0) {
            selectionKey.interestOps(interestOps | readInterestOp);
        }
    }
```
