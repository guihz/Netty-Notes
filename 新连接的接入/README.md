### Netty 的接收客户端 Channel 处理逻辑

- 在 NioEventLoop 的启动中，当 Channel 已经注册到 Selector 后，会调用 [NioEventLoop#processSelectedKey()](https://github.com/martin-1992/Netty-Notes/blob/master/NioEventLoop/NioEventLoop%20%E7%9A%84%E5%90%AF%E5%8A%A8/processSelectedKeys.md) 对不同 IO 事件进行轮询处理。调用 [unsafe.read()](https://github.com/martin-1992/Netty-Notes/blob/master/%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%85%A5/%E6%A3%80%E6%B5%8B%E6%96%B0%E8%BF%9E%E6%8E%A5.md) 检测到 accpet 或 read 事件进行处理，主要是服务端 Channel 获取客户端的连接 Channel，将其包装成 [NioSocketChannel](https://github.com/martin-1992/Netty-Notes/blob/master/%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%85%A5/NioSocketChannel.md)，设置客户端的连接 Channel 设置禁止 Nagle 算法；
- 调用 pipeline#fireChannelRead 方法，会从头节点 head 开始往下传播，传播到 [ServerBootstrap#channelRead](https://github.com/martin-1992/Netty-Notes/blob/master/%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%85%A5/ServerBootstrap%23channelRead.md)，会将该客户端 Channel 注册到服务端 Channel 对应的 Selector 上；
- 当客户端连接 Channel 注册到 Selector 后，具体注册可看 [register](https://github.com/martin-1992/Netty-Notes/blob/master/Netty%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/register.md)，会对该 Channel 进行 [读事件的注册](https://github.com/martin-1992/Netty-Notes/blob/master/%E6%96%B0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%85%A5/%E8%AF%BB%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C.md)，添加到 SelectionKey 中，表示对读事件感兴趣。这里客户端 Channel 注册到服务端 Selector 流程和服务端 Channel 注册到 Selector 的流程是一致的。
